# LeetCode 题解 #
## GitHub地址：<https://github.com/fx2003/OI/tree/master/LeetCode> ##
## CopyRight Ace Li ##
***



### 1. 找出和为Target的两个数的序号 ###
利用Map映射不同数的位置，利用find查找需要值是否存在，存在即返回，不存在即添加。
***

### 2. 计算两个链表代表的数的和 ###
分别从头开始遍历链表，由于从个位开始存入，因此直接计算两个的和与进位项相加，得到的结果存入新的链表即可。
***

### 3. 计算最长不重复子序列 ###
定义一个Hash数组，从头开始存入各字母位置，当遇见重复的时候，利用该位置可以更新最长序列的长度。
***

### 4. 计算两个有序数列的中位数 ###
利用两个变量分别定位两个数列，利用数学关系，得到总数列中位数的对应的两个数列的地方。得到过程中，用二分法随时根据需要搜索左区间或右区间。找到分界点后，对比两数列左分界点取最大值，两数列右分界点取最小值。如果数列长度为奇数，则直接输出左分界点最大值，否则取分界点的平均值。
***

### 5. 最长回文子序列 ###
循环子序列的中心的同时，在子序列中心展开计算最长回文子序列。
***

### 9. 回文数 ###
取该数的一半的逆，并和原数进行对比。（然而不懂，明明不能有其他空间，为什么还是开了个变量）
***

### 11. 包含最大面积 ###
分别从左右两边将较小的向内侧移动，求出最大面积。
***

**14

### 19. 删除链表的倒数第n个节点 ###
利用两个指针，先将1号指针指向离开头n+1的位置，再同时移动俩指针，一直到第一个指针为空，则第二个指针指向的下一个元素就是要删除的。需要注意的是，为了考虑边界情况，需要在head前加一个指向head的指针作为参考原点。
***

### 26. 删除数组中重复的元素 ###
利用erase，从后往前扫参数即可
***

### 27. 删除数组中特定的元素 ###
与26类似，利用erase，从后往前扫参数即可
***

### 31. 下一个排列 ###
从后往前找相邻元素前者比后者小的，然后再从后往前找比之前的前元素大的元素，并交换两者，然后反向排列后者元素到最后的元素
***

### 32. 最长有效括号对 ###
将（的序号压入栈，当碰到）时弹出栈顶元素，这个时候，如果栈空了，就将当前值压入，否则，通过当前序号减去现栈顶序号得到长度，再将长度与最长值比较。
***

### 55. 确认是否能从第一格跳至最后一格 ###
从后往前利用DP，只要能达到最后一个点就是True，然后把当前点当做最后点处理。
***

### *64. 最短路径 ###
采用动归，寻找最小的路径。
dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
***

### 70. 上到n个台阶的方法数量 ###
利用Fibonacci数列求解公式，直接求n+1处值。
Fibonacci(n) = (((1 + sqrt(5)) / 2) ^ (n + 1) - ((1 - sqrt(5)) / 2) ^ (n + 1)) / sqrt(5);
***

### 83. 删除有序列表中重复的元素 ###
直接从头到尾循环判断当前值是否等于下一值，是则令指向下个的指针指向下下个元素，否则当前指针后移。
***

**84

### 101. 对称树 ###
1、DFS。分别递归两节点判断左右子树的情况，如果都为NULL则返回True，如果值不等，返回False。
2、BFS。分别将两节点放入队列中，并通过队列判断，如果值不等，返回False，如果都为NULL则Continue，全部执行完成返回True。
***

### 121. 最好的买卖时间 ###
直接循环寻找最小值，同时用当前值减最小值与最大利润对比。
***



\* 代表教程需要会员

\** 代表已经Solved但是忘记怎么写的了（待完善）
***
# LeetCode 题解 #
## GitHub地址：<https://github.com/fx2003/OI/tree/master/LeetCode> ##
## CopyRight Ace Li ##